DB : bien, encore mieux d’ajouter quelques entrées avec des accents ou &<> pour tester les échappements. 
Que se passe-t-il si dans le $event dans Logger il y a déjà un \n ? injection d’entrées de log ? 
Login : de préférence mettre un exit() après le header(Location), même si dans votre cas ce n’est probablement pas absolument nécessaire, mais c’est un bon réflexe – ou créer un helper ! 
session_destroy() : lisez la documentation pour voir les alternatives. 
Recommandation de hacher le mdp. 
Le contrôleur login() viole le MVC vu qu’il affiche de l’HTML : il fallait p.ex. passer le message d’erreur par la session et l’afficher dans la view login, après un redirect sémantique. 
TaskController : passer le message par la variable updated GET est possible, toutefois, plus sûr par la session, ce qui permettrait de généraliser. ParseUpdate() lui passe par redirect sémantique bien, et passe le message via GET aussi. 
ParseDelete() : sert à rien de chercher la tâche : plutôt valider qu’id est un entier, puis DELETE, si affected rows == 0, pas marché, sinon fenêtre de vulnérabilité SELECT/DELETE sans transactions isolées. 
Model : pas mal, encore que fetchId et fetchNimporteQuelleColonneUnique est un peu la même chose, ce qui permettrait d’éviter le fetchName(). 
Un peu dommage d’injecter la dépendance de session dans fetchId, passer en paramètre serait mieux : requête un peu plus générique avec contraintes dans un tableau associatif ? 
Save() : pas des question marks cf votre requête. 
models/Task.php : un urlencode() autour de $this→id ne gènerait pas dans asHTMLTabl*. 
User : 4 lignes pour regretter mdp pas haché, ça m’aurait semblé prendre moins de temps d’écrire le code : fetchName() généralisable dans Model. 
Contrôle d’accès : un peu par accident quand vous faites le fetchId() vous contrôlez la session, mais c’est plutôt dans les routes ou dans le contrôleur qu’il faudrait le faire : d’autant plus que parseUpdate() lui ne vérifie pas que la tâche appartient à l’utilisateur (l’update() est fait avant le fetchId!). 